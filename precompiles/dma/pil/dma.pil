const int DMA_BUS_ID = 8000;
const int DMA_ROM_ID = 8001;

const int DMA_MEM_CPY = 1;
const int DMA_MEM_PRE_POST = 2;
const int DMA_MEM_EQ = 3;

const int MEM_CPY_BYTE_CONT_ID = 8200;
const int MEM_CPY_CONT_ID = 8201;



airtemplate Dma(int N = 2**21, const int RC = 2, const int op_x_row = 4, const int selectors = 1) {

    assert(selectors == 0 || selectors == 1);
    assert(op_x_row > 1);

    // DMA: MEMCPY
    //
    // Unlike a CPU memcpy, the DMA memcpy is instantaneous from a temporal point of view all reads 
    // occur in the same step and all writes in the next step. In the case of reads there are no 
    // problems in performing the same read several times in the same step because the result is 
    // always the same in this moment. In the case of writes, this is not the case, because it would 
    // create an ambiguity to know the written value. Therefore, we must guarantee that each 64-bit 
    // value is written only once.
    //
    // The strategy that DMA follows in the case of memcpy is to divide the operation into 3 phases:
    //
    // 1. Pre-copy: initial bytes are copied to achieve at least destination alignment, to avoid
    //    double writes.
    //
    // 2. Fully or partially aligned copy. It's a loop where 64-bit values are copied. There are 
    //    two variants:
    //    a) Aligned 64-bit copy: both source and destination addresses are aligned to 8 bytes.
    //    b) Unaligned 64-bit copy: the source address is not aligned to 8 bytes, but it's read in
    //       bytes and 64-bit values are reassembled.
    // 
    // 3. Post-copy: final bytes that don't complete a 64-bit word are copied.
    // 
    // Not all phases are necessary, they depend on the copy parameters.
    //
    // Example of fully aligned memcpy operation:
    //             
    //                PRE                 MEMCPY                 POST       
    //           ┌──────────┐ ┌──────────────────────────────┐ ┌──────────┐ 
    //
    //               ┌──────┐ ┌────────┬────────┐   ┌────────┐ ┌────┐
    //    src        │  0   │ │    1   │    2   │...│    n   │ │ n+1│  
    //               └──────┘ └────────┴────────┘   └────────┘ └────┘
    //                  ↓          ↓        ↓            ↓        ↓
    //           ┌───┬──────┐ ┌────────┬────────┐   ┌────────┐ ┌────┬─────┐
    //    dst    │      0   │ │    1   │    2   │...│    n   │ │ n+1      │
    //           └───┴──────┘ └────────┴────────┘   └────────┘ └────┴─────┘
    //           ^dst64       ^dst64+1 ^dst64+2     ^dst64+n   ^dst64+n+1   <-- each dst64 address is 
    //                                                                          written only once
    //
    // 
    // Example of partially aligned memcpy operation:
    //              
    //                PRE                 MEMCPY                            POST       
    //           ┌──────────┐ ┌────────────────────────────────────────┐ ┌──────────┐ 
    //               ┌────┐┌─ ┌────────┬────────┐   ┌────────┐┌─┬──────┐ ┌─┬───┐
    //    src        │  0 ││1 │    1   │    2   │...│    n   ││   n+1  │ │  n+1│  
    //               └────┘└─ └────────┴────────┘   └────────┘└─┴──────┘ └─┴───┘
    //                  ↓   ↓      ↓   ↙   ↓    ↙        ↓    ↙              ↙
    //           ┌───┬──────┐ ┌────────┬────────┐   ┌────────┐           ┌────┬─────┐
    //    dst    │      0   │ │    1   │    2   │...│    n   │     ↑     │ n+1      │
    //           └───┴──────┘ └────────┴────────┘   └────────┘     │     └────┴─────┘
    //           ^dst64       ^dst64+1 ^dst64+2     ^dst64+n       │      ^dst64+n+1   <-- each dst64 address is 
    //                                                          without                    written only once
    //                                                           write
    //
    
    // read count from register directly

    // assuming max memory of 512Mb (29 bits)
    // count: 21 bits RC + 5 bits T
    col witness bits(24) h_count;
    col witness bits(1) count_ge_32;
    col witness bits(6) l_count;        // 0..31 + 32 = 6 bits
    // l_count range verified with dma_rom table
    const expr count = h_count * 32 + l_count;

    count_ge_32 * (1 - count_ge_32) === 0;
    (1 - count_ge_32) * h_count === 0;

    range_check(expression: h_count - count_ge_32, min: 0, max: 2**21-1);


    // 32 bit address
    // 21 bits RC +  8 bits RC + 3 bits T
    col witness bits(21) h_src64;
    col witness bits(8) l_src64;
    col witness bits(3) src_offset;
    const expr src = h_src64 * 2**21 + l_src64 * 2**3 + src_offset;
    const expr src64 = h_src64 * 2**21 + l_src64 * 2**3;
    // src_offset range verified with dma_rom table


    // 32 bit address
    // 21 bits RC +  8 bits RC + 3 bits T
    col witness bits(21) h_dst64;
    col witness bits(8) l_dst64;
    col witness bits(3) dst_offset;
    const expr dst = h_dst64 * 2**21 + l_dst64 * 2**3 + dst_offset;
    const expr dst64 = h_dst64 * 2**21 + l_dst64 * 2**3;
    // dst_offset range verified with dma_rom table

    col witness bits(MAIN_STEP_BITS) main_step;
    col witness bits(1) sel;

    sel * (1 - sel) === 0;

    range_check(expression: h_src64, min: 0, max: 2**21-1);
    range_check(expression: h_dst64, min: 0, max: 2**21-1);
    range_dual_byte(l_src64, l_dst64);

    col witness bits(1) use_pre;            // use memcpy_pre operation
    col witness bits(1) use_memcpy;         // use memcpy operation
    col witness bits(1) use_post;           // use memcpy_post operation  
    col witness bits(1) src64_inc_by_pre;   // src64 increment after apply memcpy_pre operation

    use_pre * (1 - use_pre) === 0;
    use_memcpy * (1 - use_memcpy) === 0;
    use_post * (1 - use_post) === 0;
    src64_inc_by_pre * (1 - src64_inc_by_pre) === 0;

    const expr flags = use_pre + use_memcpy * 2 + use_post * 4 + src64_inc_by_pre * 8;

    col witness bits(3) pre_count;  // number of bytes of memcpy_pre operation
    col witness bits(3) l_count64;  // number of 64 bits in l_count after substract pre_count and post_count
    col witness bits(3) src_offset_after_pre; // src_offset after apply memcpy_pre operation

    lookup_assumes(DMA_ROM_ID, expressions: [dst_offset, src_offset, l_count, flags, pre_count, src_offset_after_pre, l_count64]);

    col witness bits(1) reg_prev_mem_step; 
    precompiled_reg_load(reg: REG_A2, prev_mem_step: reg_prev_mem_step, main_step:main_step, value:[count, 0], sel: sel);


    permutation_assumes(DMA_BUS_ID, [DMA_MEM_CPY, 
        dst64 + use_pre + l_count64 + h_count * 4, 
        src64 + src64_inc_by_pre + l_count64 + h_count * 4, 
        0, 
        src_offset_after_pre, 
        l_count - pre_count - l_count64 * 8, 
        main_step], sel: use_memcpy);

    // write aligned
    // read 
    // value1, value2, key = value 3
    // (src64, dst64, pre_src_op, dst_offset)

    // verify overlapping
    // 
}