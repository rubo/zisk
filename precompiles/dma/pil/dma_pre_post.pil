//  src_addr, src_offset
//  dst_addr, dst_offset, count

airtemplate DmaPrePost(int N = 2**21) {

    col witness bits(MAIN_STEP_BITS) main_step;
    col witness bits(ADDR_W_BITS) src_addr;
    col witness bits(ADDR_W_BITS) dst_addr;
    col witness bits(3) dst_offset;
    col witness bits(3) count;

    col witness bits(1) offset_7;
    col witness bits(1) offset_6;
    col witness bits(1) offset_5;
    col witness bits(1) offset_4;
    col witness bits(1) offset_3;
    col witness bits(1) offset_2;
    col witness bits(1) offset_1;
    const expr offset_7to1 = offset_7 + offset_6 + offset_5 + offset_4 + offset_3 + offset_2 + offset_1;
    const expr offset_0 = (1 - offset_7to1);

    offset_7to1 * (offset_7to1) === 0;
    const expr src_offset = offset_1 + offset_2 * 2 + offset_3 * 3 + offset_4 * 4 + offset_5 * 5 +
                            offset_6 * 6 + offset_7 * 7;
  
    offset_7 * (1 - offset_7) === 0;
    offset_6 * (1 - offset_6) === 0;
    offset_5 * (1 - offset_5) === 0;
    offset_4 * (1 - offset_4) === 0;
    offset_3 * (1 - offset_3) === 0;
    offset_2 * (1 - offset_2) === 0;
    offset_1 * (1 - offset_1) === 0;

    col witness bits(1) enabled;
    col witness bits(1) enabled_second_read;

    enabled * (1 - enabled) === 0;
    enabled_second_read * (1 - enabled_second_read) === 0;
    enabled_second_read * (1 - enabled) === 0;

    const int V2R = 2 * 3;          // Values To Read
    const int B2R = V2R * 4;        // Bytes To Read

    col witness bits(8) bytes[B2R];
    const expr values[V2R];
    

    for (int i = 0; i < B2R; i+=2) {
        range_dual_byte(bytes[i], bytes[i+1], enabled);
    }
    
    for (int i = 0; i < V2R; ++i) { 
        values[i] = bytes[i*4] + P2_8 * bytes[i*4+1]  + P2_16 * bytes[i*4+2]  + P2_24 * bytes[i*4+3];
    }
    col witness bits(1) selb[8];
    expr mask = 0;
    for (int i = 0; i < 8; ++i) {
        selb[i] * (1 - selb[i]) === 0;
        mask += selb[i] * (1 << (7+i));
    }

    col witness bits(32) write_value[2];

    // byte_0, byte_1, byte_2, byte_3, byte_4, byte_5, byte_6, byte_7, byte_0', byte_1' ...

    write_value[0] === offset_0 * (selb[0] * bytes[0] + selb[1] * P2_8 * bytes[1] + selb[2] * P2_16 * bytes[2] + selb[3] * P2_24 * bytes[3]) +
                       offset_1 * (selb[0] * bytes[1] + selb[1] * P2_8 * bytes[2] + selb[2] * P2_16 * bytes[3] + selb[3] * P2_24 * bytes[4]) +
                       offset_2 * (selb[0] * bytes[2] + selb[1] * P2_8 * bytes[3] + selb[2] * P2_16 * bytes[4] + selb[3] * P2_24 * bytes[5]) +
                       offset_3 * (selb[0] * bytes[3] + selb[1] * P2_8 * bytes[4] + selb[2] * P2_16 * bytes[5] + selb[3] * P2_24 * bytes[6]) +
                       offset_4 * (selb[0] * bytes[4] + selb[1] * P2_8 * bytes[5] + selb[2] * P2_16 * bytes[6] + selb[3] * P2_24 * bytes[7]) +
                       offset_5 * (selb[0] * bytes[5] + selb[1] * P2_8 * bytes[6] + selb[2] * P2_16 * bytes[7] + selb[3] * P2_24 * bytes[8]) +
                       offset_6 * (selb[0] * bytes[6] + selb[1] * P2_8 * bytes[7] + selb[2] * P2_16 * bytes[8] + selb[3] * P2_24 * bytes[9]) +
                       offset_7 * (selb[0] * bytes[7] + selb[1] * P2_8 * bytes[8] + selb[2] * P2_16 * bytes[9] + selb[3] * P2_24 * bytes[10]) +
                       (1 - selb[0]) * bytes[16] + (1 - selb[1]) * P2_8 * bytes[17] + (1 - selb[2]) * P2_16 * bytes[18] + (1 - selb[3]) * P2_24 * bytes[19];
               
    write_value[1] === offset_0 * (selb[4] * bytes[4]  + selb[5] * P2_8 * bytes[5]  + selb[6] * P2_16 * bytes[6]  + selb[7] * P2_24 * bytes[7]) +
                       offset_1 * (selb[4] * bytes[5]  + selb[5] * P2_8 * bytes[6]  + selb[6] * P2_16 * bytes[7]  + selb[7] * P2_24 * bytes[8]) +
                       offset_2 * (selb[4] * bytes[6]  + selb[5] * P2_8 * bytes[7]  + selb[6] * P2_16 * bytes[8]  + selb[7] * P2_24 * bytes[9]) +
                       offset_3 * (selb[4] * bytes[7]  + selb[5] * P2_8 * bytes[8]  + selb[6] * P2_16 * bytes[9]  + selb[7] * P2_24 * bytes[10]) +
                       offset_4 * (selb[4] * bytes[8]  + selb[5] * P2_8 * bytes[9]  + selb[6] * P2_16 * bytes[10] + selb[7] * P2_24 * bytes[11]) +
                       offset_5 * (selb[4] * bytes[9]  + selb[5] * P2_8 * bytes[10] + selb[6] * P2_16 * bytes[11] + selb[7] * P2_24 * bytes[12]) +
                       offset_6 * (selb[4] * bytes[10] + selb[5] * P2_8 * bytes[11] + selb[6] * P2_16 * bytes[12] + selb[7] * P2_24 * bytes[13]) +
                       offset_7 * (selb[4] * bytes[11] + selb[5] * P2_8 * bytes[12] + selb[6] * P2_16 * bytes[13] + selb[7] * P2_24 * bytes[14]);
                       (1 - selb[4]) * bytes[20] + (1 - selb[5]) * P2_8 * bytes[21] + (1 - selb[6]) * P2_16 * bytes[22] + (1 - selb[7]) * P2_24 * bytes[23];

    
    // MEMORY ACCESS
    //
    // Read first 64 bits
    // Read next 64 bits (optional, only if enabled_second_read)
    // Read previous value before write
    // Write final value

    precompiled_mem_load( sel: enabled, main_step: main_step, addr: src_addr * 8,     value: [values[0], values[1]]);
    precompiled_mem_load( sel: enabled_second_read, main_step: main_step, addr: src_addr * 8 + 8, value: [values[2], values[3]]);
    precompiled_mem_load( sel: enabled, main_step: main_step, addr: dst_addr * 8,     value: [values[4], values[5]]);
    precompiled_mem_store(sel: enabled, main_step: main_step, addr: dst_addr * 8,     value: write_value);

    // Send operation to bus
    permutation_proves(DMA_BUS_ID, [DMA_MEM_PRE_POST, src_addr, dst_addr, src_offset, dst_offset, count, main_step], sel: enabled);

    const expr flags = mask + src_offset * P2_8 + dst_offset * P2_11 + count * P2_14 + enabled_second_read * P2_17;
    lookup_assumes(DMA_PRE_POST_TABLE_ID, [flags], sel: enabled);
}